The discussion thus far has focused on spatial data in the domain of a single
processor system with the R-tree stored all on one disk. We now extend the 
scope of our survey of R-trees into the topics of parallel systems, 
spatiotemporal databases, and applications of R-trees.

% Went for a weird title..... can be changed :P
\subsection{R-trees in the Parallel Universe}
Before we begin our overview of R-trees in a parallel environment, we first 
explain some basic definitions. There are three levels of resource sharing in
a parallel system: shared everything, shared disk, and shared nothing
\cite{thebook}. Shared everything means that all processors share all 
resources including disk and memory. Shared disk means that each processor 
has its own private memory but share disks. Unsurprisingly, shared nothing 
architectures have private memory and disk for each processor, which
communicate using some type of network. Thus the basic challenge for R-tree 
implementation in such systems boils down to exploiting parallelism to 
increase both CPU and I/O performance. In the following sections we discuss
R-trees in multidisk, single-cpu systems and in multiprocessor systems.

\subsection{R-trees in Multidisk Systems}
The architecture of a multidisk system consists of a single processor and 
multiple disks. The focus then in these types of systems is I/O parallelism
and how to partition data to maximize performance while maintaining good load
balance. Below are a few structures that fall under this category.

\subsubsection{Independent R-trees}
The independent R-tree method \cite{kamel1992parallel}\cite{thebook} uses separate R-tree structures for each disk.
Data is distributed using two approaches: data distribution and space 
partitioning. The former uses hashing or round-robin (RR) to assign disks to
R-tree entries. The second partitions the R-tree into sections such that 
child nodes reside on the same disk as their parents. The first approach 
has good data load distribution but poor locality, whereas the second approach
has good locality but could have worse throughput on large queries.

\subsubsection{Super-node R-tree}
In the super-node method \cite{kamel1992parallel}\cite{thebook} there is only
one R-tree structure for the system. Each node in the structure consists of
\emph{d} pages distributed across \emph{d} disks. When node is accessed, each
page of the node (one page per disk) is read in parallel. This has the 
advantage of good load balancing, but it has the disadvantage of
always touching every disk regardless of the query.

\subsubsection{Multiplexed R-tree}
\cite{kamel1992parallel} tackles the problem of data partitioning with the 
multiplexed R-tree (MX R-tree), which is essentially the same as the R-tree 
in \cite{guttman84} but distributes the nodes across different disks. 
The root node always resides in main memory, and all other nodes reside on 
disk. Cross-disk pointers are used to refer to child nodes residing in 
different disks. 

Disk assignment is performed with the conflicting criteria of
data balance, where the number of nodes are partitioned equally across disks, 
area balance, where the total area covered by each disk is approximately 
equal, and proximity, where close nodes are put on separate disks in order to
maximize throughput. \cite{kamel1992parallel} examines several placement 
heuristics but determines that proximity index (PI) has the best performance. 
The proximity index is essentially a measure of the probability that two MBRs
will be retrieved by the same query. Thus in the PI scheme nodes are assigned 
to disk with the proximity index with data balance as the tiebreaker criteria.

\cite{kamel1992parallel} determines that the MX R-tree is outperforms the two
other methods of node-to-disk distribution both in terms of query latency and
load.
 
\subsection{R-trees in Multiprocessor systems}
More recent research has focused on multiprocessor systems, especially in 
lieu of the growing popularity of distributed services and multicpu processors.
The multiprocessor system, unlike the multidisk system, consists of multiple 
processors. This could be in either a multicore machine in a shared-resource
environment or a distributed system with many machines in a shared-nothing 
environment. As before, there is a tradeoff between performance and load 
balancing; however, in this case scalability, availability, and consistency
are additional challenges. We examine several R-tree variants that exist in
the shared-nothing domain and also discuss R-trees in the context of parallel 
implementation issues.

%Shared something R-trees
\subsubsection{Master R-trees}
The Master R-tree (M-Rtree)\cite{koudas1996declustering} is an R-tree variant 
for distributed systems.
In this structure, there are two different types of machines: \emph{master} and 
\emph{client}. Suppose there is some R-tree $X$ that we wish to represent using 
the M-Rtree. The master contains a R-tree structure that contains the non-leaf 
nodes of $X$, and the leaf nodes of $X$ reside in the clients as pages. The leaf 
level in the master instead has information on which client has the desired page has the form ($siteID$, $pageID$), where $siteID$ refers to the client on which
the data resides. Note that there is only one master, and it holds the root of 
the M-Rtree structure.
Thus a query must contact the master, which searches the portion of the M-Rtree 
in its memory. All clients in the resultant list (after all relevant master leaf 
entries have been touched) of relevant $siteID$ and $pageID$ pairs are then sent 
the query MBR and the $pageID$. Each client then fetches the page, checks for 
pertinent objects, and sends back the results to the master. 

In this scheme, parallel search processing occurs among the clients, but the 
master is inherently a source of bottleneck since all operations must be sent to
it.

%Shared nothing R trees
\subsubsection{Master-Client R-trees}
Another variant for the shared-nothing environment is the Master-Client R-tree 
(MC-Rtree) proposed in \cite{schnitzer1999master},  which is similar to the 
M-Rtree in the previous section except that instead of having a R-tree index 
structure residing only in the master, each client also has a subtree. As before,
the master holds only non-leaf nodes; however, the leaf level entries on the 
master are of the form ($mbr$, $siteID$). Moreover, the clients each have R-tree
structures that index the objects assigned to that site. This means that on a 
query it traverses the tree as usual, and as soon as a master leaf has been 
touched it stores the client $siteID$ in a list and sends the query MBR to the 
site, which processes the request. The master then waits for clients to respond
with any overlapping objects. 

In contrast to the M-Rtree, the MC-Rtree does not wait to send a request to
clients, and \cite{schnitzer1999master} finds that it has significantly better 
response time than the M-Rtree due to the reduced network contention and the 
reduced latency from issuing non-blocking requests to clients as soon as a leaf 
is reached rather than waiting until the whole tree has been searched. Also 
there is less time spent in the master tree is smaller since the clients hold 
more parts of the tree than the M-Rtree. However, this approach is also limited
by the fact that all requests must go through the master.

%Other trees from before 2005?

%dR-tree... see references in p2pr paper.

\subsubsection{P2PR-Tree}
% From 2005! cool!
In \cite{mondal2005p2pr} Mondal, Lifu, and Kitsuregawa examine extending the 
R-tree structure for use in peer-to-peer (P2P) systems. The challenge in P2P 
systems is not only the huge number of machines but heterogeneity among them as 
well. Thus \cite{mondal2005p2pr} proposes the P2PR-tree, which is a 
decentralized hierarchical tree structure built with scalability and availability
in mind. 

In the P2P environment, each peer (machine) has a unique \emph{peerID} and holds
an R-tree covered by a MBR (\emph{peerMBR}). The P2PR-tree is structured
such that the top two levels (level 0 and level 1) of the index are statically 
assigned and lower levels are dynamically assigned. Entries in level 0 (the root)
are called \emph{blocks} and entries in level 1 are called \emph{groups}. Each 
peer stores a copy of the root node and all nodes in the path from the root to 
the peerMBR. PeerMBRs that overlap with multiple group MBRs are inserted into 
both corresponding subtrees. Since the top two levels of the tree are static, 
this tree is not height-balanced\cite{mondal2005p2pr}.

When a query is issued, it may be handled by any peer. When a peer receives a 
query, it checks if its peerMBR overlaps with the query MBR. If so it performs 
a search on its local R-tree structure and completes. Otherwise, it checks the 
node at the current query level (starts at 0 and gets incremented every time it
is forwarded) and forwards the query to any peer in each overlapping entry (each
peer knows one or more peers in each block).

Compared to the MC-Rtree of \cite{schnitzer1999master}, the P2PR-tree performs
very well. \cite{mondal2005p2pr} finds that this decentralized technique 
dramatically decreases response time since it does
not require each query to be processed by a master. However, the P2PR-tree can
still suffer from the effects of skewed data sets since ``hot'' nodes may have
higher response time if many requests are sent to it. 

\subsubsection{SD-Rtree}
% from 2007! cooler!
The last multiprocessor R-tree variant we discuss is the scalable distributed R-tree
(SD-Rtree) of \cite{du2007sd}. Instead of a B-tree-like structure with a large
fanout, this structure is a binary tree residing on a set of servers.
Internal nodes maintain the ID of its parent and links to its two children of 
the form ($id$, $mbr$, $height$, $type$), where $id$ is the ID of the server 
storing that child, $height$ is the height of the child subtree, and $type$ 
indicates whether the child is a leaf or an internal node. Each leaf node stores 
the indexed objects, as usual.

\cite{du2007sd} circumvents the problem of congestion in upper level nodes by 
maintaining an \emph{image} which holds a snapshot of the tree and determines 
the server that most likely has the desired data. On receipt of a query, a 
server first checks its image and then forwards the query to the server it 
supposes holds the data. If it exists on the target server, then it returns the
desired data. Otherwise, the server examines the SD-Rtree from bottom up until a 
node containing the query MBR is found and sends back a message fixing the 
out-of-date image. %Similar to \cite{schniter1999master}, 
%each data node maintains the path from root to the node and uses 
%this information to forward the query when necessary. This also helps with 
%load balancing on the upper levels.

Both SD-Rtree and P2PR-tree are able to decentralize query handling and are able
to scale up well. P2PR-tree has the advantage of having a completely dynamic 
structure, but it does have additional memory cost due to having an image of the 
index structure at each server.

% ACID?
\subsection{Parallel System Implementation Issues}
With the introduction of additional processes in a database there inherently
comes the issue of correctness. Operations may contend for the same data 
structure and without some method of concurrency control we have no guarantees
on the data in the database. We focus on the topics of concurrency control, 
recovery, and data migration. 

\begin{description}
	\item[Concurrency Control] R-link tree.
	\item[Recovery] ARIES and R-trees.
	\item[Data Migration] How to migrate data.
\end{description}

\subsection{R-trees in Spatiotemporal Databases}
There is extensive research for using R-tree variants in spatiotemporal
databases. Essentially spatiotemporal databases add time as an extra dimension
in addition to spatial data. This added dimensionality creates new challenges
such as deciding whether to split nodes based on spatial data or temporal data. 
This also adds several new types of queries. \emph{Time slice}
queries search for all objects intersected by an area at a certain time. 
\emph{Interval} queries request all objects intersected by an area during a time
interval.

The R-tree variants used in spatiotemporal databases can be categorized based
on the time used for indexing data. Structures may index historical 
spatiotemporal data, current data, or future data. These are described more
in detail below.

\subsubsection{Indexing Historical Data}
These \rbase-tree variants index spatiotemporal data for past data. One challenge
in this domain is that history of an objects grows over time, which means 
careful consideration of how and what data to store is important. This is 
typically handled using sampling or updating only when there is a change in the
data. 

\begin{description}
	\item[RT-tree] The RT-tree\cite{xu1990rt} uses separate \rbase-tree and 
	TSB-tree structures. The former is used 
	to index the spatial aspect of the data and the latter is used to index
	the temporal data. A TSB-tree is a B-tree that maintains an index on an 
	entry based on the $oid$ and time. When an object is inserted into the 
	database, it is placed in the R-tree with an entry of form 
	($oid$, $mbr$, $t_s$, $t_e$, $p$), where $t_s$ and $t_e$ refer to the 
	start and end time with which the object corresponds. Spatial queries 
	are done as in the \rbase-tree case by traveral on the \rbase-tree 
	structure, meaning search performance on spatial data is the same as in 
	the \rbase-tree case. Temporal queries are performed on the TSB-tree. 
	RT-trees use the method of update on change to limit data history.
	\item[3D R-tree] 3D R-trees \cite{nascimento1999evaluation} are basically
	R-trees with time as another dimension. However, 3D R-trees cannot 
	query on data with open intervals. 3D R-trees typically take less
	memory than an equivalent HR-tree and 2+3R-tree but with worse query 
	performance than an HR-tree.
	\item[HR-tree] HR-trees, or historical R-trees, 
	\cite{nascimento1999evaluation} uses the idea of overlapping trees to 
	increase the storage utility of the tree. This means that multiple 
	versions of the R-tree corresponding to different times are stored such 
	that only the modified nodes with respect to a previous version are 
	held in later trees. So, supposing there are two times $t1$ and $t2$, the
	structure for $t2$ will point to nodes that are different from $t1$ and
	each node of $t2$ will point to either another node in $t2$ or a node in
	$t1$ (unmodified data). As mentioned before, this tree has better query
	performance than the RT-tree and 2+3R-tree, but takes more memory.
	\item[STR-tree] \cite{pfoser2000novel}
	\item[TB-tree] \cite{pfoser2000novel}
	\item[MV3R-tree] \cite{tao2001mv3r}
\end{description}

\subsubsection{Indexing Current Data}
This class of spatiotemporal \rbase-trees index data on the current positions of 
objects. This poses the issue of how to maintain fresh data and what constitutes 
as "now" during a query. 

\begin{description}
	\item[2+3R-tree] A 2+3R-tree\cite{nascimento1999evaluation} uses two 
	\rbase-trees to index two-dimensional points (current data that only have
	start times for their intervals) and three dimensional trajectories 
	(historical data with closed intervals). When the end time of an 
	interval of an object is added, it first accesses the 2D \rbase-tree
	and then inserts the object trajectory into the 3D tree and deletes the 
	object from the 2D \rbase-tree. Queries on current information are 
	performed on the 2D tree and historical queries are performed on the 3D
	tree. Depending on the time used on the query, both trees may have to be 
	accessed.
	\item[2-3TR-tree] \cite{abdelguerfi20022}
	\item[LUR-tree] \cite{kwon2002indexing}
\end{description}

\subsubsection{Indexing Current and Future Positions}
The main focus of the variants in this section is to keep track of the current
and future locations of objects. This is suitable for worksets in which 
objects have predictable behavior such as projectile motion and traveling in
straight lines.

Challenges:

\begin{description}
	\item[TPR-tree] \cite{vsaltenis2000indexing}
	\item[TPR*-tree] \cite{tao2003tpr}
\end{description}


\subsubsection{Database Operations}
Querying moving data
Clustering


\subsection{Applications}
R-tree variants are used in a vast variety of different applications including
but not exclusive to spatial datamining, geographic information systems, 
science and medicine, and cloud computing. We list some examples of R-trees
and variants used in these fields below.

\begin{description}
	\item[Spatial datamining]
	
	\item[Geographic information systems]
	\item[Science and medicine]
	\item[Cloud computing]
\end{description}

R-trees are also available in some form in many popular open source and 
commercial databases including MySQL Server, SQLite, Oracle$\textsuperscript{\textregistered}$ Spatial, IBM$\textsuperscript{\textregistered}$ DB2, and 
PostgreSQL. 
