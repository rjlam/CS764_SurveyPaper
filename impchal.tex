\newcommand{\keyword}[1]{\textbf{#1}}

The R-tree was introduced with the search, or \keyword{range} query.
Soon it was being applied to a variety of other queries.
Its apparent universality for spatial queries is natural motivation for improving R-tree performance.
In this section we discuss various advances beyond Guttman's original design.
Along the way we hope to imply some intuition about the underlying theory for R-tree performance.
In the next section we show what formal theory and considerations for R-trees have so far been developed.

Before delving into the improvements for R-trees it is important to provide some impression of the broad context in which we find R-trees.
Namely, what are the spatial queries R-trees are used for?
How are these queries efficiently satisfied using the structure of the R-tree?
As it happens there is an inordinate number of queries for which R-trees may be used, and we cannot hope to catalog them all here.
One broad classification scheme groups queries into three types.
\keyword{Topological} queries are based on basic geometric properties of the data.
The quintessential \keyword{range} query falls into this category.
\keyword{Directional} queries involve predicates of the form ``above'', or ``east''---filtering according to global positions.
An example of this is skyline, or dominating points computations.
Lastly, \keyword{distance} queries consider distance between data elements.
The exemplar here is nearest-neighbor computation.
Within these three categories there exists a great many queries.
Even accounting for the different types of topological relations between MBRs is a daunting task \cite{papadiassellistheodoridisegenhofer95}.
Also note that these categories are not a neat partition: would the ``nearest surrounder'' query be directional or distance?

In light of this overwhelming diversity we will consider just three queries and walk through their execution on an R-tree.
The goals of this in-depth examination are three:
provide a context for the reader to keep in mind as we discuss R-tree improvements;
demonstrate how R-trees can service very different queries;
demonstrate how---despite their differences---these varied queries share similar bottlenecks in the R-tree, implying general optimizations are possible.
The three queries are \keyword{range}, \keyword{spatial join}, and \keyword{nearest neighbor}.

\subsection{The Range Query}
The range query is perhaps the simplest spatial query and remains essentially unchanged since its introduction \cite{guttman84}.
The idea is this: given a database of $R$ spatial objects represented by their MBRs and an input rectangle $s$, output all $r\in R$ such that $r\cap s\neq\emptyset$.
Described briefly in English: at sub-tree $T$, recurse at each child if that child's MBR has a nonempty intersection with $s$.
If $T$ is a leaf, output $T$ if it has a nonempty intersection with $s$.
There exist many variations---perhaps the query is only for objects strictly containing, or contained within, $s$ \cite{gaedegunther95}.
This general query's popularity has warranted intense study, and extensive tests have compared how R-tree variants perform on different inputs \cite{papadiassellistheodoridisegenhofer95}.

We take the time here to emphasize that even in this fundamental query there exist complications beyond just the various forms the query can take.
Some thought reveals that a range query can result in output equal to $\emptyset$ or to the whole tree.
Moreover, this is true even if the range is the degenerate case: the point.
A surprising fact is that there exist R-trees and queries such that the output is $\emptyset$ but the \emph{whole tree must be traversed}.
This is true not just for Guttman's initial R-tree, but many advanced types as well (see Theorem 3 of \cite{argeberghaverkortyi04}).
As testament to its utility, we note that the range query on R-trees was adapted to \emph{approximating similarities between frequencies} \cite{agrawalfaloutsosswami93} by mapping the $k$ major features of the DFT transform into $k$-dimensional space.
\subsection{The Spatial Join}
\subsection{The Nearest Neighbor Query}
\subsection{Optimization Intuition}
From these three queries, the underlying cause of inefficiency is obvious: that for any non-leaf node, the MBR does not give us all the information we need to know if we should explore it or not.
If we are wasteful during a range query, it is because our inner node MBRs are so big-but-sparse that we have to search them despite their children's empty intersection.
We can be wasteful during a join for much the same reason.
In a nearest neighbor search, if the inner MBRs do not provide a good approximation of their children, then the MINDIST values would fail to allow much pruning in our branch-and-bound.
Informally speaking, it seems that all these queries suffer if the inner MBRs cover much more area than their children, or the inner MBRs have a much greater degree of overlap with each other than the actual data (leaves).
So in our efforts to improve our R-tree performance, we want to somehow grow a ``better-organized tree''.
Implicit in this desire is an important difference between B-trees and R-trees.
Consider a set of data $\mathcal S$, an index $I$ implying an order-of-insertion for those elements $s\in \mathcal S$, and the B-tree $B_I$, generated by inserting $s_{i+1}$ into $B_I$ after $s_{i}$.
Whatever $I$ we choose, by the linear nature of $\mathcal S$, the resulting $B_I$ will not differ ``too much'' from any $B_{I\prime}$.
Obviously, the leaves always end up in the same order.
However, this is \emph{not} the case at all for R-trees.
Given $I$ and $I\prime$, the R-trees $R_I$ and $R_{I\prime}$ may wildly differ in terms of the inner nodes created.
Thus our idea of growing an R-tree in a ``smarter'' fashion has real meaning.

\paragraph{Node Splitting}
As a basic R-tree's construction (and hence performance) is somewhat at the mercy of its insertion order, a natural first step to improving R-trees is to take the time to split nodes so that the tree maintains a good structure.
When faced with the task of splitting a node in a B-tree, the split is obvious.
When splitting an R-tree node, however, we have the freedom and burden to choose among $\binom{M}{m}$ possible partitions of $M$ data points into 2 sets of size $m=\frac{M}{2}$.
In conceiving the R-tree Guttman realized the importance of a ``good'' split and proposed three algorithms for it.
Then R*,R+,Hilbert,Optimal,etc.

\paragraph{Static R-Tree Construction}
These algorithms are all, by necessity, on-line.
What if we consider the input being provided statically?
This is far from contrived: the 1930 census data is unlikely to change.


\paragraph{Applying Static Advancements to Dynamic R-Trees}
Bulk loading, lazy, grafting, static analysis.


\paragraph{Changing the R-tree}
Understanding the R+, Hilbert tree in this way.

\paragraph{Other optimality}
Space usage.

\paragraph{Super-dynamic}
Mobile data, constantly changing data, etc.


\paragraph{Provable Optimality}



% While we have seen a complete description of the behavior of the R-tree, in a sense our description is far from complete.
% In this and the next section we will place R-trees in broader contexts.
% 
% As the R-tree stores spatial data, implicitly it is designed to support queries based on the spatial relationships of the data.
% Thus, in this section we discuss a variety of spatial queries the R-tree supports, and to what degree of efficiency.
% In moving towards the natural goal of efficient R-trees, we will discuss various successful strategies in optimizing the core data structure.
% As often happens, different settings lead to further specializations and design decisions, so a discussion on the tweaks and other optimizations of R-trees will follow.
% 
% In the next section we explore in particular the optimality and formal analysis of R-trees.
% Spatial data is much slipperier than ordered data, and developing a model to explain the behavior of R-trees is a natural motivation after we have seen its various forms.
% On this note we will conclude our discussion on R-tree's state-of-the-art.
% 
% \subsection{Basic Queries, Data Model}
% 
% The prototypical R-tree is introduced as storing axis-aligned rectangles: basic spatial data.
% As R-trees store spatial data according to their spatial relationships, it follows that R-trees support spatial queries.
% This necessitates the question: just what is a spatial query?
% We list many examples.
% 
% The initial---and still ubiquitous---query examples are \keyword{select} and \keyword{join} \cite{gaedegunther98,theodoridisstefanakissellis00}.
% The \keyword{select} query is a natural extension of the typical \keyword{select} but also taking spatial predicates.
% A catalog from \cite{gaedegunther98} includes 
% \begin{itemize}
% \item Point query, find the set of rectangles $R$ in our R-tree containing point $p$.
% \item Window query, find the rectangles with non-empty intersection with our rectangle.
% \item Intersection query, find all rectangles with non-empty intersection with our shape.
% \item Enclosure query, find all rectangles strictly containing our rectangle.
% \item Containment query, find all rectangles containing our shape.
% \item Adjacency query, find all rectangles that are super-next to each other (???)
% \item Nearest-neighbor.
% \item Spatial join.
% \end{itemize}
% Nearest neighbor queries \cite{roussopouloskelleyvincent95}. Note also \emph{dynamic} variants, big deal.
% Spatial join \cite{brinkhoffkriegelseeger93}.
% Skyline computation \cite{papadiastaofuseeger05}.
% Convex Hull \cite{papadiastaofuseeger05}.
% Nearest Surrounder \cite{leeleeleong10}.
% Perimeter \cite{samet95}.
% 
% Data model, how do we do it, distributions, etc. Lots of questions.
% Here's a histogram: \cite{achakeevseeger12}.
% 
% How do we insert data?
% Bulk loading \cite{garcialopezleutenegger98}.
% Modern bulk loading, see \cite{yi12} for many citations.
% \subsection{General Optimizations}
% R-trees are fast, but we can make them faster.
% First, what do we really mean by fast?
% Formal model of what makes an R-tree go fast or slow: \cite{theodoridisstefanakissellis00}.
% Does there exist an optimal R-tree? Yes: \cite{argeberghaverkortyi04}.
% Areas for optimization: R* has the main points down \cite{beckmannkriegelschneiderseeger90}.
% Node splitting \cite{garcialopezleutenegger98}.
% Index optimization \cite{gavrila94}.
% 
% Hopefully it is clear from these diverse applications that it is not enough to pour all our efforts into optimizing for one query.
% It seems difficult to improve an R-tree design over all these objectives, but some general successes have been made:
% [R*, Front-loading, node splitting, space utilization (grafting), and more.]
% 
% \subsection{Data-Dependent Optimizations}
% As one considers the nature of the stored data and the nature of the queries, we are able to specialize more.
% [R+, static data, Hilbert gives data ordering (b-tree linearity), using not just distribution but fractal stuff]
% Dynamic data.
% 
% \subsection{Extensions to the R-Tree}
% Concurrent R-trees \cite{kornackerbanks95}.
% Historical R-trees \cite{nascimentosilva98}.
% Nearest neighbor over mobile data, extremely dynamic trees, are a big deal \cite{leeleeleong10}.
% 
% 
% Polygon, X-tree, maybe R+ tree again.
% Dynamic, constantly-changing spatial data (MOBILE DATA)
% 
% %
%  %\subsection{What sort of queries}
%  %Find all objects $a \in A$ with $a\cap r\neq \emptyset$.
%  %Spatial join, in infinite varieties. \cite{brinkhoffkriegelseeger93}.
%  %Nearest neighbors \cite{roussopouloskelleyvincent95}.
%  %Big survey on spatial stuff \cite{gaedegunther98}.
%  %Optimal R-tree \cite{argeetal04}.
%  %Index optimization \cite{gavrila94}
%  %Optimal node splitting \cite{garcialopezleutenegger98}
%  %\subsection{Challenges in Fulfilling those queries}
%  %Not very nicely structured.
%  %See \cite{gaedegunther98} for a good overview.
